# Пояснение
На все вопросы я попытался ответить так, как будто это вопрос или код от студента. Максимально развернуто и с пояснением.

## Как отработает этот код? Выдаст ли ошибку? Если да, то почему и как ее исправить?

````
let n1: Int = 1
let n2: Float = 2.0
let n3: Double = 3.34
var result = n1 + n2 + n3
````

Код выдаст ошибку, потому что свифт не любит такие приколы. В отличие от других языков у него нету четких правил приведений к какому-то типу. Их придется писать самим в зависимости от того, какой result мы хотим видеть.

````
let n1: Int = 1
let n2: Float = 2.0
let n3: Double = 3.34
var result: Int = n1 + Int(n2) + Int(n3)
````

или

````
let n1: Int = 1
let n2: Float = 2.0
let n3: Double = 3.34
var result: Double = Double(n1) + Double(n2) + n3
````
## Как улучшить этот код?

````
func turnTo(direction: String){
    if direction == "North" {
        northAction()
    } else if direction == "East" {
        eastAction()
    } else if direction == "South" {
        southAction()
    } else if direction == "West" {
        westAction()
    } else {
        print("No valid direction specified")
    }
}
````

Можно использовать switch, но проблема в том, что используя его со строкой, мы всегда получим поле **default**, что устраивает нас на этой задаче, но в последствие - это ведет к багам. Поэтому проще переписать все на **enum** с rawValue: String.

````
enum Direction: String {
	case north = "North"
	case east = "East"
	case south = "South"
	case west = "West"
}

func turnTo(direction: String) {
	guard let direction = Direction(rawValue: direction) else {
		print("No valid direction specified")
		return
	}
	switch direction {
		case .north: northAction()
		case .east: eastAction()
		case .south: southAction()
		case .west: westAction()
	}
}
````

Теперь, если мы захотим расширить наш список направлений и добавим  *eastNorth* - компилятор нам подскажет везде, где это случай надо отработать и добавить.

## Force unwrapping: когда им нужно пользоваться?

**Никогда**. Но! Иногда если мы хотим явно указать какой-то контракт, что до какого-то момент поле не будет инициализировано, его можно использовать с огромным количеством оговорок (пример, view! в UIViewController).

## Что такое strong reference cycle и как его избежать? Где искать утечку памяти?

Начнем немного издалека. Допустим мы создаем объект (класс), и возникает вопрос: как нам объяснить системе, сколько нам держать этот объект в памяти? Ответ самый простой - столько сколько понадобится. Ведь если мы будем держать все объекты вечно, то никакой памяти (особенно телефона) не хватит.

Для этого в iOS Разработке существует система ARC (автоматическая система подсчета ссылок).

Что это значит? Мы считаем количество ссылок на объект, который нам нужен, и если это количество больше 0, то мы держим его в памяти. Ведь в обратно случае (== 0) логично, что объект уже никому не нужен.

Но возникает трудность, которую нужно всегда держать в уме. Что будет если 1 объект создаст сильную ссылку на другой, а тот создаст ссылку на первый. ARC без нашей помощи не сможет разобраться, можно ли удалить эти объекты и когда. Это и называется **strong reference cycle**. Почему именно сильная? Потому есть еще разновдиности ссылок (слабая и бесхозная) - их уже ARC игнорирует.

Заметить утечку памяти и strong reference cycle можно в тулзе от Xcode Leaks. А более детально разобраться в Graph Memory.

## Ревью кода

Все комменты по коду я оставил в пр-е. 
Саму работу я бы оценил в зависимоти от того, как давно начал учить свифт. Если неделю назад - круто, что он смог написать что-то такое. Но работа очень слабая, поэтому дерзать и дерзать.
Если студент уже учит iOS месяца 2, то это очень плохо. Я бы рекомендовал студенту еще раз прошерстить про ARC, CollectionView (reusable Cells), Clean Architecture (момент, где объясняется про разганичение - и зачем нам нужно, чтобы 1 класс не знал про другое), DRY, Разницу между == и ===.
